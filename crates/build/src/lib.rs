#![allow(non_local_definitions)] // TODO: Fix downstream in bart

use anyhow::*;
use common::{FileHash, ModManifest, RawWasmVec};
use postprocess::TypeAddress;
use sha2::{Digest, Sha256};
use std::{path::PathBuf, time::Instant};
use tracing::{info, warn};
use wasmtime::*;

mod command;
use command::{CargoCommand, GenericCommand};

mod fs_utils;
mod postprocess;
mod templates;

pub async fn build(
    release: bool,
    mods_directory: PathBuf,
    cargo_directory: PathBuf,
) -> Result<Vec<PathBuf>> {
    let start = Instant::now();
    info!("Building mods from {:?}", mods_directory);

    let mut sources = ModSource::from_dir(&mods_directory).await?;
    if sources.is_empty() {
        warn!("There are no mods to build");
        return Ok(Vec::new());
    }

    let dir = Directories::create(cargo_directory, release).await?;

    // Prepare codegen
    fs_utils::empty_dir_conditional(&dir.codegen, |path| {
        // Avoid deleting the empty crate which is kept version controled
        !path.ends_with("empty")
    })
    .await?;
    for source in sources.iter_mut() {
        source.codegen(&dir).await?;

        // Assuming mod manifests didn't change since last build, we might be able to compile everything with one single cargo build command
        // This might fail if no manifest was generated for this mod yet
        let _ = source.codegen_final(&dir).await;
    }

    // Try building everything in one go
    if let Err(e) = cargo_build(
        &dir,
        sources
            .iter()
            .flat_map(|source| source.get_packages())
            .collect(),
        release,
    )
    .await
    {
        warn!("Initial cargo build ran into an error:\n{:?}", e);
        info!("Retrying building manifests only");

        // Build only the mod manifests
        cargo_build(
            &dir,
            sources
                .iter()
                .map(|source| source.get_manifest_export_package())
                .collect(),
            release,
        )
        .await?;
    } else {
        info!("Initial cargo build succeeded");
    }

    // Generate and process manifest exports
    bindgen(
        &dir,
        sources
            .iter()
            .map(|source| source.get_manifest_export_package())
            .collect(),
    )
    .await
    .with_context(|| "Failed to bindgen manifest export")?;
    for source in sources.iter_mut() {
        source.write_manifests(&dir).await?;
    }

    // Filter out mods whose manifest changed
    let packages: Vec<String> = sources
        .iter()
        .filter_map(|source| {
            if source.codegen_manifest_hash.is_some() {
                Some(source.get_manifest_export_package())
            } else {
                None
            }
        })
        .collect();

    // All manifests export crates should have their wasm binaries generated by now
    for source in sources.iter_mut() {
        source.write_manifests(&dir).await?;
    }

    // Those mods whose manifest didn't change don't need to be built again
    let mut remaining_sources = sources
        .iter()
        .filter(|source| !source.completed_codegen())
        .cloned()
        .collect::<Vec<_>>();

    if !remaining_sources.is_empty() {
        // Regenerate the codegen for the remaining sources
        for source in remaining_sources.iter_mut() {
            source.codegen_final(&dir).await?;
        }

        // Build the remaining sources
        cargo_build(
            &dir,
            sources
                .iter()
                .map(|source| source.get_systems_export_package())
                .collect(),
            release,
        )
        .await?;
    }

    bindgen(
        &dir,
        sources
            .iter()
            .map(|source| source.get_systems_export_package())
            .collect(),
    )
    .await?;

    // Delete old wasm files
    fs_utils::empty_dir_conditional(&dir.dest, |path| path.ends_with(".wasm")).await?;

    // Move the generated wasm files to the build directory
    let mut wasm_files = Vec::with_capacity(sources.len());
    for source in sources.iter() {
        wasm_files.push(source.finish(&dir).await?);
    }

    let duration = start.elapsed();
    info!("Successfully built mods {:?} in {:?}", packages, duration);

    Ok(wasm_files)
}

struct Directories {
    cargo_directory: PathBuf,
    dev_mode: &'static str,
    codegen: PathBuf,
    temp: PathBuf,
    dest: PathBuf,
    wasm_dest: PathBuf,
}

impl Directories {
    const TARGET_DIR: &str = "target";
    const BUILD_DIR: &str = "bevy-harmonize-build";
    const CODEGEN_DIR: &str = "codegen/crates";
    const WASM_TARGET: &str = "wasm32-unknown-unknown";

    async fn create(cargo_directory: PathBuf, release: bool) -> Result<Self> {
        let cargo_directory = dunce::canonicalize(cargo_directory)?;
        let target = cargo_directory.join(Self::TARGET_DIR);
        let build = target.join(Self::BUILD_DIR);
        let temp = build.join("temp");
        let codegen = cargo_directory.join(Self::CODEGEN_DIR);
        let dev_mode = if release { "release" } else { "debug" };
        let dest = build.join(dev_mode);
        let wasm_dest = target.join(Self::WASM_TARGET).join(dev_mode);

        fs_utils::create_dir_all(&codegen).await?;
        fs_utils::create_dir_all(&dest).await?;

        Ok(Self {
            cargo_directory,
            codegen,
            dev_mode,
            temp,
            dest,
            wasm_dest,
        })
    }

    fn bindgen_path(&self, package_name: &str) -> PathBuf {
        self.temp
            .join(&package_name)
            .join(format!("{}_bg.wasm", package_name))
    }
}

/// A source file for a mod
#[derive(Clone, Debug)]
pub struct ModSource {
    source: PathBuf,
    name: String,
    codegen_manifest_hash: Option<FileHash>,
}

impl ModSource {
    async fn from_dir(path: &PathBuf) -> Result<Vec<Self>> {
        let files = fs_utils::list_files_in_dir(path).await?;
        let mut sources = Vec::new();
        for file in files {
            if file.extension().map_or(false, |ext| ext == "rs") {
                let path = dunce::realpath(file)?;
                sources.push(Self::new(path));
            }
        }
        Ok(sources)
    }

    fn new(source: PathBuf) -> Self {
        let path_hash: [u8; 32] = Sha256::digest(source.as_os_str().as_encoded_bytes()).into();
        let package_suffix: String = path_hash[..4]
            .iter()
            .map(|byte| format!("{:02x}", byte))
            .collect();

        let name = source.file_stem().unwrap().to_str().unwrap();
        let package_name = format!(
            "{}_{}",
            name.to_lowercase().replace(" ", "_"),
            &package_suffix
        );

        Self {
            source,
            name: package_name,
            codegen_manifest_hash: None,
        }
    }

    const MANIFEST: &str = ".manifest";
    const MANIFEST_DEBUG: &str = ".manifest.txt";
    const SOURCE: &str = "_source";
    const IMPORTS: &str = "_imports";
    const EXPORT_MANIFEST: &str = "_export_manifest";
    const EXPORT_SYSTEMS: &str = "_export_systems";

    fn completed_codegen(&self) -> bool {
        self.codegen_manifest_hash.is_some()
    }

    fn get_packages(&self) -> Vec<String> {
        let mut packages = vec![self.get_manifest_export_package()];
        if self.completed_codegen() {
            packages.push(self.get_systems_export_package());
        }
        packages
    }

    fn get_manifest_export_package(&self) -> String {
        format!("{}{}", self.name, Self::EXPORT_MANIFEST)
    }

    fn get_systems_export_package(&self) -> String {
        format!("{}{}", self.name, Self::EXPORT_SYSTEMS)
    }

    /// Performs the initial codegen, before mod manifests are necessarily resolved
    async fn codegen(&self, dir: &Directories) -> Result<()> {
        let name = &self.name;
        let file_name = self.source.file_name().unwrap().to_str().unwrap();
        let source_file = &self.source.to_str().unwrap().replace("\\", "/");
        let modloader_version = env!("CARGO_PKG_VERSION");
        let dev_mode = dir.dev_mode;

        let imports_path = dir.codegen.join(format!("{}{}", name, Self::IMPORTS));
        fs_utils::write_template(
            imports_path.join("Cargo.toml"),
            templates::ImportsCargo {
                file_name,
                modloader_version,
                dev_mode,
                name,
            },
        )
        .await?;
        fs_utils::write_template(
            imports_path.join("lib.rs"),
            templates::ImportsLib {
                // Empty since we don't know the contents of the manifest yet
                components: Vec::new(),
            },
        )
        .await?;

        let source_pkg_path = dir.codegen.join(format!("{}{}", name, Self::SOURCE));
        fs_utils::write_template(
            source_pkg_path.join("Cargo.toml"),
            templates::SourceCargo {
                file_name,
                modloader_version: env!("CARGO_PKG_VERSION"),
                dev_mode,
                name,
                source_file,
            },
        )
        .await?;

        let export_manifest_path = dir
            .codegen
            .join(format!("{}{}", name, Self::EXPORT_MANIFEST));
        fs_utils::write_template(
            export_manifest_path.join("Cargo.toml"),
            templates::ExportsManifestCargo {
                file_name,
                modloader_version,
                dev_mode,
                name,
            },
        )
        .await?;
        fs_utils::write_template(
            export_manifest_path.join("lib.rs"),
            templates::ExportsManifestLib {},
        )
        .await?;

        Ok(())
    }

    /// Reads the manifest binary and generates codegen
    async fn codegen_final(&mut self, dir: &Directories) -> Result<()> {
        let name = &self.name;
        let file_name = self.source.file_name().unwrap().to_str().unwrap();
        let modloader_version = env!("CARGO_PKG_VERSION");
        let dev_mode = dir.dev_mode;

        let manifest_path = dir.dest.join(format!("{}{}", self.name, Self::MANIFEST));
        let manifest_bytes = fs_utils::read(&manifest_path).await?;
        let manifest: ModManifest = bitcode::decode(&manifest_bytes)
            .with_context(|| format!("Failed to read manifest file: {:?}", manifest_path))?;

        let components: Vec<_> = TypeAddress::from_type_signatures(manifest.types.iter())
            .enumerate()
            .map(|(id, type_address)| {
                let sid = type_address.ty.stable_id();
                templates::ImportsComponent {
                    name: format!("{}::{}", sid.crate_name, sid.name),
                    id: id as u32,
                    address: type_address.address,
                }
            })
            .collect();

        warn!("{:?}", components);

        let imports_path = dir.codegen.join(format!("{}{}", name, Self::IMPORTS));
        fs_utils::write_template(
            imports_path.join("lib.rs"),
            templates::ImportsLib { components },
        )
        .await?;

        let systems: Vec<_> = manifest
            .systems()
            .iter()
            .enumerate()
            .map(|(id, system)| templates::ExportsSystem {
                id: id as u32,
                name: system.name,
            })
            .collect();

        let export_systems_path = dir
            .codegen
            .join(format!("{}{}", name, Self::EXPORT_SYSTEMS));
        fs_utils::write_template(
            export_systems_path.join("Cargo.toml"),
            templates::ExportsSystemsCargo {
                file_name,
                modloader_version,
                dev_mode,
                name,
            },
        )
        .await?;
        fs_utils::write_template(
            export_systems_path.join("lib.rs"),
            templates::ExportsSystemsLib {
                systems: &systems[..],
            },
        )
        .await?;

        self.codegen_manifest_hash = Some(FileHash::from_sha256(
            Sha256::digest(&manifest_bytes).into(),
        ));

        Ok(())
    }

    /// Uses the built wasm manifest export to generate the mod manifest
    ///
    /// Then it writes the manifest to the build directory
    async fn write_manifests(&mut self, dir: &Directories) -> Result<()> {
        let package_name = self.get_manifest_export_package();
        let path = dir.bindgen_path(&package_name);

        let mut config = Config::new();
        config.cache_config_load_default()?;
        config.parallel_compilation(true);

        let engine = Engine::new(&config)?;
        let mut store = Store::new(&engine, ());
        let module = Module::from_file(&engine, path)?;

        let mut linker = Linker::new(&engine);
        let memory = Memory::new(&mut store, MemoryType::new(18, None))?;
        linker.define(&store, "env", "memory", memory)?;

        let module_name = format!("./{}_bg.js", package_name);
        linker.func_wrap(&module_name, "__wbindgen_throw", |_: i32, _: i32| {})?;
        linker.func_wrap(&module_name, "__wbindgen_init_externref_table", || {})?;

        let instance = linker
            .instantiate(&mut store, &module)
            .with_context(|| "Error instantiating wasm module for manifest")?;

        let run = instance.get_typed_func::<(), u64>(&mut store, "run")?;
        let vec = RawWasmVec::from(run.call(&mut store, ())?);

        let memory = instance.get_memory(&mut store, "memory").unwrap();
        let manifest_bytes = memory.data(&store)[vec.into_range()].to_vec();

        if manifest_bytes.is_empty() {
            bail!("Manifest bytes are empty");
        }

        if self
            .codegen_manifest_hash
            .as_ref()
            .map(|hash| {
                hash != &common::FileHash::from_sha256(Sha256::digest(&manifest_bytes).into())
            })
            .unwrap_or(true)
        {
            if self.codegen_manifest_hash.is_some() {
                warn!("Manifest changed for {}", self.name);
            }

            let manifest: ModManifest = bitcode::decode(&manifest_bytes)?;

            let as_string = format!("{:#?}", manifest);
            let path = dir
                .dest
                .join(format!("{}{}", self.name, Self::MANIFEST_DEBUG));
            fs_utils::write(&path, as_string).await?;

            let encoded_manifest = bitcode::encode(&manifest);
            let path = dir.dest.join(format!("{}{}", self.name, Self::MANIFEST));
            fs_utils::write(&path, encoded_manifest).await?;

            // Clear the codegen manifest hash, since the previous codegen code is no longer valid
            self.codegen_manifest_hash = None;
        }

        Ok(())
    }

    async fn finish(&self, dir: &Directories) -> Result<PathBuf> {
        let package_name = self.get_systems_export_package();
        let src = dir.bindgen_path(&package_name);
        let dest = dir.dest.join(format!("{}.wasm", self.name));

        fs_utils::rename(&src, &dest).await?;

        Ok(dest)
    }
}

async fn cargo_build(dir: &Directories, packages: Vec<String>, release: bool) -> Result<()> {
    let mut command = CargoCommand::new("build")?;
    command
        .packages(packages.into_iter())
        .current_dir(dir.cargo_directory.clone())
        .target("wasm32-unknown-unknown")
        //.arg("build-std=panic_abort,std")
        .env("RUSTFLAGS", "-C link-arg=--import-memory");

    if release {
        command.arg("--release");
    }

    command.spawn().await?;

    Ok(())
}

async fn bindgen(dir: &Directories, packages: Vec<String>) -> Result<()> {
    fs_utils::create_dir_all(&dir.temp).await?;

    for package in packages {
        let mut command = GenericCommand::new("wasm-bindgen")?;
        command
            .current_dir(dir.cargo_directory.clone())
            .arg(dir.wasm_dest.join(format!("{}.wasm", package)))
            .arg("--out-dir")
            .arg(dir.temp.join(package));

        command.spawn().await?;
    }

    Ok(())
}
